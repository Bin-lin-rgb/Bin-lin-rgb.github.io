<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>计算机网络 | Blaine&#39;s Blog</title>
<meta name="keywords" content="计算机网络">
<meta name="description" content="基础篇 OSI 七层参考模型 它是⼀个七层的、抽象的模型体，不仅包括⼀系列抽象的术语或概念，也包括具体的协议。 物理层：它的主要作⽤是传输⽐特流 数据链路层：建⽴逻辑连接、进⾏硬件地址寻址、差错校验等功能。定义了如何让格式化数据以帧为单位进⾏传 输，以及如何控制对物理介质的访问。将⽐特组合成字节">
<meta name="author" content="Blaine">
<link rel="canonical" href="https://Bin-lin-rgb.github.io/posts/basics/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.js" onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://Bin-lin-rgb.github.io/img/icon.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://Bin-lin-rgb.github.io/img/icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://Bin-lin-rgb.github.io/img/icon.png">
<link rel="apple-touch-icon" href="https://Bin-lin-rgb.github.io/img/icon.png">
<link rel="mask-icon" href="https://Bin-lin-rgb.github.io/img/icon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script defer src="https://unpkg.com/mermaid@8.8.1/dist/mermaid.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js"></script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = ""; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<meta property="og:title" content="计算机网络" />
<meta property="og:description" content="基础篇 OSI 七层参考模型 它是⼀个七层的、抽象的模型体，不仅包括⼀系列抽象的术语或概念，也包括具体的协议。 物理层：它的主要作⽤是传输⽐特流 数据链路层：建⽴逻辑连接、进⾏硬件地址寻址、差错校验等功能。定义了如何让格式化数据以帧为单位进⾏传 输，以及如何控制对物理介质的访问。将⽐特组合成字节" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://Bin-lin-rgb.github.io/posts/basics/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-29T16:34:43+08:00" />
<meta property="article:modified_time" content="2023-10-29T16:34:43+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="计算机网络"/>
<meta name="twitter:description" content="基础篇 OSI 七层参考模型 它是⼀个七层的、抽象的模型体，不仅包括⼀系列抽象的术语或概念，也包括具体的协议。 物理层：它的主要作⽤是传输⽐特流 数据链路层：建⽴逻辑连接、进⾏硬件地址寻址、差错校验等功能。定义了如何让格式化数据以帧为单位进⾏传 输，以及如何控制对物理介质的访问。将⽐特组合成字节"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [

        {
          "@type": "ListItem",
          "position":  1 ,
          "name": "📚文章",
          "item": "https://Bin-lin-rgb.github.io/posts/"
        },

        {
          "@type": "ListItem",
          "position":  2 ,
          "name": "📖 基础",
          "item": "https://Bin-lin-rgb.github.io/posts/basics/"
        }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "计算机网络",
      "item": "https://Bin-lin-rgb.github.io/posts/basics/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "计算机网络",
  "name": "计算机网络",
  "description": "基础篇 OSI 七层参考模型 它是⼀个七层的、抽象的模型体，不仅包括⼀系列抽象的术语或概念，也包括具体的协议。 物理层：它的主要作⽤是传输⽐特流 数据链路层：建⽴逻辑连接、进⾏硬件地址寻址、差错校验等功能。定义了如何让格式化数据以帧为单位进⾏传 输，以及如何控制对物理介质的访问。将⽐特组合成字节",
  "keywords": [
    "计算机网络"
  ],
  "articleBody": "基础篇 OSI 七层参考模型 它是⼀个七层的、抽象的模型体，不仅包括⼀系列抽象的术语或概念，也包括具体的协议。\n物理层：它的主要作⽤是传输⽐特流\n数据链路层：建⽴逻辑连接、进⾏硬件地址寻址、差错校验等功能。定义了如何让格式化数据以帧为单位进⾏传 输，以及如何控制对物理介质的访问。将⽐特组合成字节进⽽组合成帧，⽤ MAC 地址访问介质。\n⽹络层：进⾏逻辑地址寻址，在位于不同地理位置的⽹络中的两个主机系统之间提供连接和路径选择。Internet 的发展使得从世界各站点访问信息的⽤户数⼤⼤增加，⽽⽹络层正是管理这种连接的层。\n传输层：定义了⼀些传输数据的协议和端口号，如：TCP UDP\n会话层：通过传输层（端口号：传输端口与接收端口）建⽴数据传输的通路。主要在你的系统之间发起会话或者 接受会话请求。\n表⽰层：数据的表⽰、安全、压缩。\n应⽤层：⽹络服务与最终⽤户的⼀个接口。\nTCP/IP 网络模型有哪几层？ TCP/IP 网络通常是由上到下分成 4 层，分别是应用层，传输层，网络层和网络接口层。\n键入网址到网页显示，期间发生了什么？ 浏览器做的第一步工作是解析 URL ，DNS 解析， 生产 HTTP 请求信息\n通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的协议栈。浏览器通过调用 Socket 库，来委托协议栈工作\nHTTP 是基于 TCP 协议传输的。三次握手建立连接。TCP 报文生成。\nTCP 委托 IP 模块将数据封装成网络包发送给通信对象。IP 报文生成。\n网络包还需要在 IP 头部的前面加上 MAC 头部。\n再通过网卡、交换机、路由器发送出去。\nHTTP 基本概念 HTTP 是超文本传输协议，也就是HyperText Transfer Protocol。\nHTTP 常见的状态码有哪些？ 五大类 HTTP 状态码\n1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。\n2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。\n「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。\n「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。\n「206 Partial Content」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。\n3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。\n「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。\n「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。\n301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。\n「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。 4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。\n「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。\n「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。\n「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。\n5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。\n「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。\n「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。\n「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。\n「503 Service Unavailable」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。\nGet 和 Post GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、可被缓存的。\nPOST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 不安全，不幂等，（大部分实现）不可缓存。\nHTTP 缓存技术 强制缓存 使用 Cache-Control 来实现强缓存。具体的实现流程如下：\n当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；\n浏览器再次请求访问服务器中的该资源时，会先通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期，如果没有，则使用该缓存，否则重新请求服务器；\n服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。\n协商缓存 协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存。\n协商缓存可以基于两种头部来实现。\nLast-Modified\n第一种：请求头部中的 If-Modified-Since 字段与响应头部中的 Last-Modified 字段实现，这两个字段的意思是：\n响应头部中的 Last-Modified：标示这个响应资源的最后修改时间；\n如果资源又被改过，则返回最新资源，HTTP 200 OK；\n如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。\nETag\n第二种：请求头部中的 If-None-Match 字段与响应头部中的 ETag 字段，这两个字段的意思是：\n响应头部中 Etag：唯一标识响应资源；\n请求头部中的 If-None-Match：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。\n当使用 ETag 字段实现的协商缓存的过程：\n当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；\n当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：\n如果没有过期，则直接使用本地缓存；\n如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；\nHTTP 与 HTTPS 有哪些区别？ HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。\nHTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。\n两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。\nHTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。\n那既然有 RPC 了，为什么还要有 HTTP 呢？ 现在电脑上装的各种联网软件，比如 xx管家，xx卫士，它们都作为客户端（Client）需要跟服务端（Server）建立连接收发消息，此时都会用到应用层协议，在这种 Client/Server (C/S) 架构下，它们可以使用自家造的 RPC 协议，因为它只管连自己公司的服务器就 ok 了。\n但有个软件不同，浏览器（Browser），不管是 Chrome 还是 IE，它们不仅要能访问自家公司的服务器（Server），还需要访问其他公司的网站服务器，因此它们需要有个统一的标准，不然大家没法交流。于是，HTTP 就是那个时代用于统一 Browser/Server (B/S) 的协议。\n也就是说在多年以前，HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合。很多软件同时支持多端，比如某度云盘，既要支持网页版，还要支持手机端和 PC 端，如果通信协议都用 HTTP 的话，那服务器只用同一套就够了。而 RPC 就开始退居幕后，一般用于公司内部集群里，各个微服务之间的通讯。\n那这么说的话，都用 HTTP 得了，还用什么 RPC？\n我们来看看 RPC 和 HTTP 区别比较明显的几个点。\n1、服务发现\n首先要向某个服务器发起请求，你得先建立连接，而建立连接的前提是，你得知道 IP 地址和端口。这个找到服务对应的 IP 端口的过程，其实就是服务发现。\n在 HTTP 中，你知道服务的域名，就可以通过 DNS 服务去解析得到它背后的 IP 地址，默认 80 端口。\n而 RPC 的话，就有些区别，一般会有专门的中间服务去保存服务名和IP信息，比如 Consul 或者 Etcd，甚至是 Redis。想要访问某个服务，就去这些中间服务去获得 IP 和端口信息。由于 DNS 也是服务发现的一种，所以也有基于 DNS 去做服务发现的组件，比如CoreDNS。\n可以看出服务发现这一块，两者是有些区别，但不太能分高低。\n2、底层连接形式\n以主流的 HTTP/1.1 协议为例，其默认在建立底层 TCP 连接之后会一直保持这个连接（Keep Alive），之后的请求和响应都会复用这条连接。\n而 RPC 协议，也跟 HTTP 类似，也是通过建立 TCP 长链接进行数据交互，但不同的地方在于，RPC 协议一般还会再建个连接池，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，用完放回去，下次再复用，可以说非常环保。\n由于连接池有利于提升网络请求性能，所以不少编程语言的网络库里都会给 HTTP 加个连接池，比如 Go 就是这么干的。\n可以看出这一块两者也没太大区别，所以也不是关键。\n3、传输的内容\n基于 TCP 传输的消息，说到底，无非都是消息头 Header 和消息体 Body。\nHeader 是用于标记一些特殊信息，其中最重要的是消息体长度。\nBody 则是放我们真正需要传输的内容，通过 Json，Protobuf 的序列化和反序列化\nHTTP 报文的内容非常多的冗余，显得非常啰嗦。最明显的，像 Header 里的那些信息，其实如果我们约定好头部的第几位是 Content-Type，就不需要每次都真的把\"Content-Type\"这个字段都传过来，类似的情况其实在 body 的 Json 结构里也特别明显。\n而 RPC，因为它定制化程度更高，可以采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据，同时也不需要像 HTTP 那样考虑各种浏览器行为，比如 302 重定向跳转啥的。因此性能也会更好一些，这也是在公司内部微服务中抛弃 HTTP，选择使用 RPC 的最主要原因。\n当然上面说的 HTTP，其实特指的是现在主流使用的 HTTP/1.1，HTTP/2 在前者的基础上做了很多改进，所以性能可能比很多 RPC 协议还要好，甚至连 gRPC 底层都直接用的 HTTP/2。\n总结\n纯裸 TCP 是能收发数据，但它是个无边界的数据流，上层需要定义消息格式用于定义消息边界。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。\nRPC 本质上不算是协议，而是一种调用方式，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时 RPC 有很多种实现方式，不一定非得基于 TCP 协议。\n从发展历史来说，HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合。很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。\nRPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP/1.1 性能要更好，所以大部分公司内部都还在使用 RPC。\nHTTP/2.0 在 HTTP/1.1 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。\nWebSocket TCP 协议本身是全双工的，但我们最常用的 HTTP/1.1，虽然是基于 TCP 的协议，但它是半双工的，对于大部分需要服务器主动推送数据到客户端的场景，都不太友好，因此我们需要使用支持全双工的 WebSocket 协议。 在 HTTP/1.1 里，只要客户端不问，服务端就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用定时轮询或者长轮询的方式实现服务器推送(comet)的效果。 对于客户端和服务端之间需要频繁交互的复杂场景，比如网页游戏，都可以考虑使用 WebSocket 协议。 WebSocket 和 socket 几乎没有任何关系，只是叫法相似。 正因为各个浏览器都支持 HTTP协 议，所以 WebSocket 会先利用HTTP协议加上一些特殊的 header 头进行握手升级操作，升级成功后就跟 HTTP 没有任何关系了，之后就用 WebSocket 的数据格式进行收发数据。 TCP 三次握手 Linux如何查看 TCP 的连接状态查看，在 Linux 可以通过 netstat -napt 命令查看。\n为什么是三次握手？不是两次、四次？ 防止「历史连接」初始化了连接\n同步双方初始序列号\n避免资源浪费（由于没有第三次握手，服务端不清楚客户端是否收到了自己回复的 ACK 报文，所以服务端每收到一个 SYN 就只能先主动建立一个连接）\nTCP 四次挥手过程是怎样的？ 为什么 TIME_WAIT 等待的时间是 2MSL？ TIME_WAIT 状态等待 2MSL 的主要目的是确保网络中的数据包已被清除，防止连接混淆，并保证连接的可靠性。这是 TCP 协议中的一项重要设计，以确保数据传输的可靠性和安全性。\nSocket 编程 1、没有 listen，能建立 TCP 连接吗？\n答案：可以的。\n客户端是可以自己连自己的形成连接（TCP自连接），也可以两个客户端同时向对方发出请求建立连接（TCP同时打开），这两个情况都有个共同点，就是没有服务端参与，也就是没有 listen，就能 TCP 建立连接。\n2、没有 accept，能建立 TCP 连接吗？\n答案：可以的。\naccpet 系统调用并不参与 TCP 三次握手过程，它只是负责从 TCP 全连接队列取出一个已经建立连接的 socket，用户层通过 accpet 系统调用拿到了已经建立连接的 socket，就可以对该 socket 进行读写操作了。\nTCP 重传 超时重传时间 RTO 的值应该略大于报文往返 RTT 的值。\n快重传：发送1、2、3、4、5，但是 2 丢了，则回复 ack1，ack2，ack2，ack2，发现居然3个一样的ack，则说明丢包了。就是重传的时候，是重传一个，还是重传所有的问题。\nSACK 方法：实现重传机制的方式叫：SACK（ Selective Acknowledgment）， 选择性确认。这种方式需要在 TCP 头部「选项」字段里加一个 SACK 的东西，它可以将已收到的数据的信息发送给「发送方」，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。\n滑动窗口 窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。\n通常窗口的大小是由接收方的窗口大小来决定的。\n流量控制 TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。\n如果发生了先减少缓存，再收缩窗口，就会出现丢包的现象。 为了防止这种情况发生，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。\n拥塞控制 为什么要有拥塞控制呀，不是有流量控制了吗？\n前面的流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。\n1、慢启动\n慢启动门限 ssthresh （slow start threshold）状态变量。\n当 cwnd \u003c ssthresh 时，使用慢启动算法。 当 cwnd \u003e= ssthresh 时，就会使用「拥塞避免算法」。 2、进入拥塞避免算法后，它的规则是：每当收到一个 ACK 时，cwnd 增加 1\n3、正如前面所说，进入快速恢复之前，cwnd 和 ssthresh 更新：\ncwnd = cwnd/2 ，也就是设置为原来的一半; ssthresh = cwnd; 然后，进入快速恢复算法如下：\n拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）； 重传丢失的数据包； 如果再收到重复的 ACK，那么 cwnd 增加 1； IP PING 127.0.0.1 是回环地址。localhost是域名，但默认等于 127.0.0.1。 ping 回环地址和 ping 本机地址，是一样的，走的是lo0 “假网卡”，都会经过网络层和数据链路层等逻辑，最后在快要出网卡前狠狠拐了个弯， 将数据插入到一个链表后就软中断通知 ksoftirqd 来进行收数据的逻辑，压根就不出网络。所以断网了也能 ping 通回环地址。 如果服务器 listen 的是 0.0.0.0，那么此时用127.0.0.1和本机地址都可以访问到服务。 ",
  "wordCount" : "6116",
  "inLanguage": "zh",
  "datePublished": "2023-10-29T16:34:43+08:00",
  "dateModified": "2023-10-29T16:34:43+08:00",
  "author":[{
    "@type": "Person",
    "name": "Blaine"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://Bin-lin-rgb.github.io/posts/basics/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Blaine's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://Bin-lin-rgb.github.io/img/icon.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    (function () {
        let  arr,reg = new RegExp("(^| )"+"change-themes"+"=([^;]*)(;|$)");
        if(arr = document.cookie.match(reg)) {
        } else {
            if (new Date().getHours() >= 19 || new Date().getHours() < 6) {
                document.body.classList.add('dark');
                localStorage.setItem("pref-theme", 'dark');
            } else {
                document.body.classList.remove('dark');
                localStorage.setItem("pref-theme", 'light');
            }
        }
    })()

    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }
</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://Bin-lin-rgb.github.io/" accesskey="h" title="Blaine&#39;s Blog (Alt + H)">
            <img src="https://Bin-lin-rgb.github.io/img/icon.png" alt="logo" aria-label="logo"
                 height="35">Blaine&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://Bin-lin-rgb.github.io/" title="🏠 主页">
                <span>🏠 主页</span>
                </a>
            </li>
            <li>
                <a href="https://Bin-lin-rgb.github.io/posts" title="📚 文章">
                <span>📚 文章</span>
                </a>
            </li>
            <li>
                <a href="https://Bin-lin-rgb.github.io/search" title="🔍 搜索 (Alt &#43; /)" accesskey=/>
                <span>🔍 搜索</span>
                </a>
            </li>
            <li>
                <a href="https://Bin-lin-rgb.github.io/tags" title="🧩 标签">
                <span>🧩 标签</span>
                </a>
            </li>
            <li>
                <a href="https://Bin-lin-rgb.github.io/archives/" title="⏱️ 时间轴">
                <span>⏱️ 时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://Bin-lin-rgb.github.io/about" title="🙋🏻‍♂️ 关于">
                <span>🙋🏻‍♂️ 关于</span>
                </a>
            </li>
            <li>
                <a href="https://Bin-lin-rgb.github.io/links" title="🤝 友链">
                <span>🤝 友链</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main page">
<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }
</style>

<article class="post-single">
    <div id="single-content">
        <header class="post-header">
            <div class="breadcrumbs"><a href="https://Bin-lin-rgb.github.io/">🏠 主页</a>&nbsp;»&nbsp;<a href="https://Bin-lin-rgb.github.io/posts/">📚文章</a>&nbsp;»&nbsp;<a href="https://Bin-lin-rgb.github.io/posts/basics/">📖 基础</a></div>
            <h1 class="post-title">
                计算机网络
            </h1>
            <div class="post-meta">

<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }

    .parent-post-meta {
        display: flex;
        flex-wrap: wrap;
        opacity: 0.8;
    }
</style>

<span class="parent-post-meta">
    <span id="post_meta_style_1">
        <span class="fa fa-calendar-check-o"></span>
        <span>2023-10-29
            &nbsp;&nbsp;
        </span>
    </span>
    
    
    
    
    
    
    
    <span id="post_meta_style_3">
        <span class="fa fa-file-word-o"></span>
        <span>6116字
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_4">
        <span class="fa fa-clock-o"></span>
        <span>13分钟
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_5">
        <span class="fa fa-user-o"></span>
        <span>Blaine
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_6">
        <span class="fa fa-tags" style="opacity: 0.8"></span>
        <span>
            <span class="post-tags-meta">
                <a href="https://Bin-lin-rgb.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="color: var(--secondary)!important;">计算机网络</a>
            </span>
        </span>
    </span>
</span>
<span style="opacity: 0.8;">
                    <span id="post_meta_style_7">
                        &nbsp;&nbsp;
                        <span class="fa fa-eye" ></span>
                        <span>
                            <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span></span>
                            &nbsp;&nbsp;
                        </span>
                    </span>
                    <span id="post_meta_style_8">
                        <span class="fa fa-commenting-o"></span>
                        <span>
                            <script src="https://cdn.staticfile.org/twikoo/1.5.8/twikoo.all.min.js"></script>
                            <script>
                                let url = document.documentURI
                                
                                let dnsUrl = "https://Bin-lin-rgb.github.io/"
                                let urlSplit = url.split(dnsUrl)
                                let finalUrl = urlSplit[1]
                                if (finalUrl[0] !== '/') {
                                    finalUrl = '/'+finalUrl
                                }
                                twikoo.getCommentsCount({
                                    envId: "https://twikoo-api-nine-silk.vercel.app/", 
                                region: "ap-guangzhou", 
                                urls: [ 
                                    
                                    finalUrl,
                                ],
                                    includeReply: false 
                                }).then(function (res) {
                                    let count = res[0].count
                                    const obj = document.getElementById("comment_count");
                                    obj.innerText = count
                                    
                                    
                                    
                                }).catch(function (err) {
                                    
                                    console.error(err);
                                });
                            </script>
                            <span id="comment_count"></span>
                        </span>
                    </span>
                </span>

</div>
        </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%9f%ba%e7%a1%80%e7%af%87" aria-label="基础篇">基础篇</a><ul>
                        
                <li>
                    <a href="#osi-%e4%b8%83%e5%b1%82%e5%8f%82%e8%80%83%e6%a8%a1%e5%9e%8b" aria-label="OSI 七层参考模型">OSI 七层参考模型</a></li>
                <li>
                    <a href="#tcpip-%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b%e6%9c%89%e5%93%aa%e5%87%a0%e5%b1%82" aria-label="TCP/IP 网络模型有哪几层？">TCP/IP 网络模型有哪几层？</a></li>
                <li>
                    <a href="#%e9%94%ae%e5%85%a5%e7%bd%91%e5%9d%80%e5%88%b0%e7%bd%91%e9%a1%b5%e6%98%be%e7%a4%ba%e6%9c%9f%e9%97%b4%e5%8f%91%e7%94%9f%e4%ba%86%e4%bb%80%e4%b9%88" aria-label="键入网址到网页显示，期间发生了什么？">键入网址到网页显示，期间发生了什么？</a></li></ul>
                </li>
                <li>
                    <a href="#http" aria-label="HTTP">HTTP</a><ul>
                        
                <li>
                    <a href="#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5" aria-label="基本概念">基本概念</a></li>
                <li>
                    <a href="#http-%e5%b8%b8%e8%a7%81%e7%9a%84%e7%8a%b6%e6%80%81%e7%a0%81%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="HTTP 常见的状态码有哪些？">HTTP 常见的状态码有哪些？</a></li>
                <li>
                    <a href="#get-%e5%92%8c-post" aria-label="Get 和 Post">Get 和 Post</a></li>
                <li>
                    <a href="#http-%e7%bc%93%e5%ad%98%e6%8a%80%e6%9c%af" aria-label="HTTP 缓存技术">HTTP 缓存技术</a><ul>
                        
                <li>
                    <a href="#%e5%bc%ba%e5%88%b6%e7%bc%93%e5%ad%98" aria-label="强制缓存">强制缓存</a></li>
                <li>
                    <a href="#%e5%8d%8f%e5%95%86%e7%bc%93%e5%ad%98" aria-label="协商缓存">协商缓存</a></li></ul>
                </li>
                <li>
                    <a href="#http-%e4%b8%8e-https-%e6%9c%89%e5%93%aa%e4%ba%9b%e5%8c%ba%e5%88%ab" aria-label="HTTP 与 HTTPS 有哪些区别？">HTTP 与 HTTPS 有哪些区别？</a></li>
                <li>
                    <a href="#%e9%82%a3%e6%97%a2%e7%84%b6%e6%9c%89-rpc-%e4%ba%86%e4%b8%ba%e4%bb%80%e4%b9%88%e8%bf%98%e8%a6%81%e6%9c%89-http-%e5%91%a2" aria-label="那既然有 RPC 了，为什么还要有 HTTP 呢？">那既然有 RPC 了，为什么还要有 HTTP 呢？</a></li>
                <li>
                    <a href="#websocket" aria-label="WebSocket">WebSocket</a></li></ul>
                </li>
                <li>
                    <a href="#tcp" aria-label="TCP">TCP</a><ul>
                        
                <li>
                    <a href="#%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b" aria-label="三次握手">三次握手</a><ul>
                        
                <li>
                    <a href="#linux%e5%a6%82%e4%bd%95%e6%9f%a5%e7%9c%8b" aria-label="Linux如何查看">Linux如何查看</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%98%af%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e4%b8%8d%e6%98%af%e4%b8%a4%e6%ac%a1%e5%9b%9b%e6%ac%a1" aria-label="为什么是三次握手？不是两次、四次？">为什么是三次握手？不是两次、四次？</a></li></ul>
                </li>
                <li>
                    <a href="#tcp-%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b%e8%bf%87%e7%a8%8b%e6%98%af%e6%80%8e%e6%a0%b7%e7%9a%84" aria-label="TCP 四次挥手过程是怎样的？">TCP 四次挥手过程是怎样的？</a><ul>
                        
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88-time_wait-%e7%ad%89%e5%be%85%e7%9a%84%e6%97%b6%e9%97%b4%e6%98%af-2msl" aria-label="为什么 TIME_WAIT 等待的时间是 2MSL？">为什么 TIME_WAIT 等待的时间是 2MSL？</a></li></ul>
                </li>
                <li>
                    <a href="#socket-%e7%bc%96%e7%a8%8b" aria-label="Socket 编程">Socket 编程</a></li>
                <li>
                    <a href="#tcp-%e9%87%8d%e4%bc%a0" aria-label="TCP 重传">TCP 重传</a></li>
                <li>
                    <a href="#%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3" aria-label="滑动窗口">滑动窗口</a></li>
                <li>
                    <a href="#%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6" aria-label="流量控制">流量控制</a></li>
                <li>
                    <a href="#%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6" aria-label="拥塞控制">拥塞控制</a></li></ul>
                </li>
                <li>
                    <a href="#ip" aria-label="IP">IP</a><ul>
                        
                <li>
                    <a href="#ping" aria-label="PING">PING</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        
        activeElement = elements[0];
        const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
        document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
    }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        if (elements) {
            activeElement = Array.from(elements).find((element) => {
                if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                    (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                    return element;
                }
            }) || activeElement

            elements.forEach(element => {
                const id = encodeURI(element.getAttribute('id')).toLowerCase();
                if (element === activeElement){
                    document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
                } else {
                    document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
                }
            })
        }
    }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;
        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>
        <div class="post-content"><h1 id="基础篇">基础篇<a hidden class="anchor" aria-hidden="true" href="#基础篇">#</a></h1>
<h2 id="osi-七层参考模型">OSI 七层参考模型<a hidden class="anchor" aria-hidden="true" href="#osi-七层参考模型">#</a></h2>
<p>它是⼀个七层的、抽象的模型体，不仅包括⼀系列抽象的术语或概念，也包括具体的协议。</p>
<ol>
<li>
<p>物理层：它的主要作⽤是传输⽐特流</p>
</li>
<li>
<p>数据链路层：建⽴逻辑连接、进⾏硬件地址寻址、差错校验等功能。定义了如何让格式化数据以帧为单位进⾏传
输，以及如何控制对物理介质的访问。将⽐特组合成字节进⽽组合成帧，⽤ MAC 地址访问介质。</p>
</li>
<li>
<p>⽹络层：进⾏逻辑地址寻址，在位于不同地理位置的⽹络中的两个主机系统之间提供连接和路径选择。Internet
的发展使得从世界各站点访问信息的⽤户数⼤⼤增加，⽽⽹络层正是管理这种连接的层。</p>
</li>
<li>
<p>传输层：定义了⼀些传输数据的协议和端口号，如：TCP UDP</p>
</li>
<li>
<p>会话层：通过传输层（端口号：传输端口与接收端口）建⽴数据传输的通路。主要在你的系统之间发起会话或者
接受会话请求。</p>
</li>
<li>
<p>表⽰层：数据的表⽰、安全、压缩。</p>
</li>
<li>
<p>应⽤层：⽹络服务与最终⽤户的⼀个接口。</p>
</li>
</ol>
<h2 id="tcpip-网络模型有哪几层">TCP/IP 网络模型有哪几层？<a hidden class="anchor" aria-hidden="true" href="#tcpip-网络模型有哪几层">#</a></h2>
<p>TCP/IP 网络通常是由上到下分成 4 层，分别是应用层，传输层，网络层和网络接口层。</p>
<h2 id="键入网址到网页显示期间发生了什么">键入网址到网页显示，期间发生了什么？<a hidden class="anchor" aria-hidden="true" href="#键入网址到网页显示期间发生了什么">#</a></h2>
<p>浏览器做的第一步工作是解析 URL ，DNS 解析， 生产 HTTP 请求信息</p>
<p>通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的协议栈。浏览器通过调用 Socket 库，来委托协议栈工作</p>
<p>HTTP 是基于 TCP 协议传输的。三次握手建立连接。TCP 报文生成。</p>
<p>TCP  委托 IP 模块将数据封装成网络包发送给通信对象。IP 报文生成。</p>
<p>网络包还需要在 IP 头部的前面加上 MAC 头部。</p>
<p>再通过网卡、交换机、路由器发送出去。</p>
<h1 id="http">HTTP<a hidden class="anchor" aria-hidden="true" href="#http">#</a></h1>
<h2 id="基本概念">基本概念<a hidden class="anchor" aria-hidden="true" href="#基本概念">#</a></h2>
<p>HTTP 是超文本传输协议，也就是HyperText Transfer Protocol。</p>
<h2 id="http-常见的状态码有哪些">HTTP 常见的状态码有哪些？<a hidden class="anchor" aria-hidden="true" href="#http-常见的状态码有哪些">#</a></h2>
<p>五大类 HTTP 状态码</p>
<p>1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。</p>
<p>2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。</p>
<ul>
<li>
<p>「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。</p>
</li>
<li>
<p>「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</p>
</li>
<li>
<p>「206 Partial Content」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</p>
</li>
</ul>
<p>3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。</p>
<ul>
<li>
<p>「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</p>
</li>
<li>
<p>「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</p>
</li>
</ul>
<p>301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p>
<ul>
<li>「304 Not Modified」不具有跳转的含义，表示<strong>资源未修改</strong>，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li>
</ul>
<p>4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。</p>
<ul>
<li>
<p>「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。</p>
</li>
<li>
<p>「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。</p>
</li>
<li>
<p>「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</p>
</li>
</ul>
<p>5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。</p>
<p>「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</p>
<ul>
<li>
<p>「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</p>
</li>
<li>
<p>「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</p>
</li>
<li>
<p>「503 Service Unavailable」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</p>
</li>
</ul>
<h2 id="get-和-post">Get 和 Post<a hidden class="anchor" aria-hidden="true" href="#get-和-post">#</a></h2>
<p>GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、可被缓存的。</p>
<p>POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 不安全，不幂等，（大部分实现）不可缓存。</p>
<h2 id="http-缓存技术">HTTP 缓存技术<a hidden class="anchor" aria-hidden="true" href="#http-缓存技术">#</a></h2>
<h3 id="强制缓存">强制缓存<a hidden class="anchor" aria-hidden="true" href="#强制缓存">#</a></h3>
<p>使用 Cache-Control 来实现强缓存。具体的实现流程如下：</p>
<p>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</p>
<p>浏览器再次请求访问服务器中的该资源时，会先通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期，如果没有，则使用该缓存，否则重新请求服务器；</p>
<p>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</p>
<h3 id="协商缓存">协商缓存<a hidden class="anchor" aria-hidden="true" href="#协商缓存">#</a></h3>
<p>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存。</p>
<p>协商缓存可以基于两种头部来实现。</p>
<blockquote>
<p>Last-Modified</p>
</blockquote>
<p>第一种：请求头部中的 If-Modified-Since 字段与响应头部中的 Last-Modified 字段实现，这两个字段的意思是：</p>
<p>响应头部中的 Last-Modified：标示这个响应资源的最后修改时间；</p>
<p>如果资源又被改过，则返回最新资源，HTTP 200 OK；</p>
<p>如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。</p>
<blockquote>
<p>ETag</p>
</blockquote>
<p>第二种：请求头部中的 If-None-Match 字段与响应头部中的 ETag 字段，这两个字段的意思是：</p>
<p>响应头部中 Etag：唯一标识响应资源；</p>
<p>请求头部中的 If-None-Match：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</p>
<hr>
<p>当使用 ETag 字段实现的协商缓存的过程：</p>
<p>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；</p>
<p>当浏览器再次请求访问服务器中的该资源时，首先会<strong>先检查强制缓存是否过期</strong>：</p>
<p>如果没有过期，则直接使用本地缓存；</p>
<p>如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；</p>
<h2 id="http-与-https-有哪些区别">HTTP 与 HTTPS 有哪些区别？<a hidden class="anchor" aria-hidden="true" href="#http-与-https-有哪些区别">#</a></h2>
<ul>
<li>
<p>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。</p>
</li>
<li>
<p>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</p>
</li>
<li>
<p>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</p>
</li>
<li>
<p>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</p>
</li>
</ul>
<h2 id="那既然有-rpc-了为什么还要有-http-呢">那既然有 RPC 了，为什么还要有 HTTP 呢？<a hidden class="anchor" aria-hidden="true" href="#那既然有-rpc-了为什么还要有-http-呢">#</a></h2>
<p>现在电脑上装的各种联网软件，比如 xx管家，xx卫士，它们都作为客户端（Client）需要跟服务端（Server）建立连接收发消息，此时都会用到应用层协议，在这种 Client/Server (C/S) 架构下，它们可以使用自家造的 RPC 协议，因为它只管连自己公司的服务器就 ok 了。</p>
<p>但有个软件不同，浏览器（Browser），不管是 Chrome 还是 IE，它们不仅要能访问自家公司的服务器（Server），还需要访问其他公司的网站服务器，因此它们需要有个统一的标准，不然大家没法交流。于是，HTTP 就是那个时代用于统一 Browser/Server (B/S) 的协议。</p>
<p>也就是说在多年以前，HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合。很多软件同时支持多端，比如某度云盘，既要支持网页版，还要支持手机端和 PC 端，如果通信协议都用 HTTP 的话，那服务器只用同一套就够了。而 RPC 就开始退居幕后，一般用于公司内部集群里，各个微服务之间的通讯。</p>
<p>那这么说的话，都用 HTTP 得了，还用什么 RPC？</p>
<hr>
<p>我们来看看 RPC 和 HTTP 区别比较明显的几个点。</p>
<p>1、服务发现</p>
<p>首先要向某个服务器发起请求，你得先建立连接，而建立连接的前提是，你得知道 IP 地址和端口。这个找到服务对应的 IP 端口的过程，其实就是服务发现。</p>
<p>在 HTTP 中，你知道服务的域名，就可以通过 DNS 服务去解析得到它背后的 IP 地址，默认 80 端口。</p>
<p>而 RPC 的话，就有些区别，一般会有专门的中间服务去保存服务名和IP信息，比如 Consul 或者 Etcd，甚至是 Redis。想要访问某个服务，就去这些中间服务去获得 IP 和端口信息。由于 DNS 也是服务发现的一种，所以也有基于 DNS 去做服务发现的组件，比如CoreDNS。</p>
<p>可以看出服务发现这一块，两者是有些区别，但不太能分高低。</p>
<p>2、底层连接形式</p>
<p>以主流的 HTTP/1.1 协议为例，其默认在建立底层 TCP 连接之后会一直保持这个连接（Keep Alive），之后的请求和响应都会复用这条连接。</p>
<p>而 RPC 协议，也跟 HTTP 类似，也是通过建立 TCP 长链接进行数据交互，但不同的地方在于，RPC 协议一般还会再建个<strong>连接池</strong>，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，用完放回去，下次再复用，可以说非常环保。</p>
<p>由于连接池有利于提升网络请求性能，所以不少编程语言的网络库里都会给 HTTP 加个连接池，比如 Go 就是这么干的。</p>
<p>可以看出这一块两者也没太大区别，所以也不是关键。</p>
<p>3、传输的内容</p>
<p>基于 TCP 传输的消息，说到底，无非都是消息头 Header 和消息体 Body。</p>
<p>Header 是用于标记一些特殊信息，其中最重要的是消息体长度。</p>
<p>Body 则是放我们真正需要传输的内容，通过 Json，Protobuf 的序列化和反序列化</p>
<p>HTTP 报文的内容非常多的冗余，显得非常啰嗦。最明显的，像 Header 里的那些信息，其实如果我们约定好头部的第几位是 Content-Type，就不需要每次都真的把&quot;Content-Type&quot;这个字段都传过来，类似的情况其实在 body 的 Json 结构里也特别明显。</p>
<p>而 RPC，因为它定制化程度更高，可以采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据，同时也不需要像 HTTP 那样考虑各种浏览器行为，比如 302 重定向跳转啥的。因此性能也会更好一些，这也是在公司内部微服务中抛弃 HTTP，选择使用 RPC 的最主要原因。</p>
<p>当然上面说的 HTTP，其实特指的是现在主流使用的 HTTP/1.1，HTTP/2 在前者的基础上做了很多改进，所以性能可能比很多 RPC 协议还要好，甚至连 gRPC 底层都直接用的 HTTP/2。</p>
<hr>
<p>总结</p>
<p>纯裸 TCP 是能收发数据，但它是个无边界的数据流，上层需要定义消息格式用于定义消息边界。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。</p>
<p>RPC 本质上不算是协议，而是一种调用方式，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时 RPC 有很多种实现方式，不一定非得基于 TCP 协议。</p>
<p>从发展历史来说，HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合。很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。</p>
<p>RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP/1.1 性能要更好，所以大部分公司内部都还在使用 RPC。</p>
<p>HTTP/2.0 在 HTTP/1.1 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。</p>
<h2 id="websocket">WebSocket<a hidden class="anchor" aria-hidden="true" href="#websocket">#</a></h2>
<ul>
<li>TCP 协议本身是<strong>全双工</strong>的，但我们最常用的 HTTP/1.1，虽然是基于 TCP 的协议，但它是<strong>半双工</strong>的，对于大部分需要服务器主动推送数据到客户端的场景，都不太友好，因此我们需要使用支持全双工的 WebSocket 协议。</li>
<li>在 HTTP/1.1 里，只要客户端不问，服务端就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用<strong>定时轮询或者长轮询</strong>的方式实现<strong>服务器推送</strong>(comet)的效果。</li>
<li>对于客户端和服务端之间需要频繁交互的复杂场景，比如网页游戏，都可以考虑使用 WebSocket 协议。</li>
<li>WebSocket 和 socket 几乎没有任何关系，只是叫法相似。</li>
<li>正因为各个浏览器都支持 HTTP协 议，所以 WebSocket 会先利用HTTP协议加上一些特殊的 header 头进行握手升级操作，升级成功后就跟 HTTP 没有任何关系了，之后就用 WebSocket 的数据格式进行收发数据。</li>
</ul>
<h1 id="tcp">TCP<a hidden class="anchor" aria-hidden="true" href="#tcp">#</a></h1>
<h2 id="三次握手">三次握手<a hidden class="anchor" aria-hidden="true" href="#三次握手">#</a></h2>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/Bin-lin-rgb/blog-img@main/20231108203937.png" alt=""  />
</p>
<h3 id="linux如何查看">Linux如何查看<a hidden class="anchor" aria-hidden="true" href="#linux如何查看">#</a></h3>
<p>TCP 的连接状态查看，在 Linux 可以通过 netstat -napt 命令查看。</p>
<h3 id="为什么是三次握手不是两次四次">为什么是三次握手？不是两次、四次？<a hidden class="anchor" aria-hidden="true" href="#为什么是三次握手不是两次四次">#</a></h3>
<ul>
<li>
<p>防止「历史连接」初始化了连接</p>
</li>
<li>
<p>同步双方初始序列号</p>
</li>
<li>
<p>避免资源浪费（由于没有第三次握手，服务端不清楚客户端是否收到了自己回复的 ACK 报文，所以服务端每收到一个 SYN 就只能先主动建立一个连接）</p>
</li>
</ul>
<h2 id="tcp-四次挥手过程是怎样的">TCP 四次挥手过程是怎样的？<a hidden class="anchor" aria-hidden="true" href="#tcp-四次挥手过程是怎样的">#</a></h2>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/Bin-lin-rgb/blog-img@main/20231108204412.png" alt=""  />
</p>
<h3 id="为什么-time_wait-等待的时间是-2msl">为什么 TIME_WAIT 等待的时间是 2MSL？<a hidden class="anchor" aria-hidden="true" href="#为什么-time_wait-等待的时间是-2msl">#</a></h3>
<p>TIME_WAIT 状态等待 2MSL 的主要目的是确保网络中的数据包已被清除，防止连接混淆，并保证连接的可靠性。这是 TCP 协议中的一项重要设计，以确保数据传输的可靠性和安全性。</p>
<h2 id="socket-编程">Socket 编程<a hidden class="anchor" aria-hidden="true" href="#socket-编程">#</a></h2>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/Bin-lin-rgb/blog-img@main/20231108205345.png" alt=""  />
</p>
<p>1、没有 listen，能建立 TCP 连接吗？</p>
<p>答案：可以的。</p>
<p>客户端是可以自己连自己的形成连接（TCP自连接），也可以两个客户端同时向对方发出请求建立连接（TCP同时打开），这两个情况都有个共同点，就是没有服务端参与，也就是没有 listen，就能 TCP 建立连接。</p>
<p>2、没有 accept，能建立 TCP 连接吗？</p>
<p>答案：可以的。</p>
<p>accpet 系统调用并不参与 TCP 三次握手过程，它只是负责从 TCP 全连接队列取出一个已经建立连接的 socket，用户层通过 accpet 系统调用拿到了已经建立连接的 socket，就可以对该 socket 进行读写操作了。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/Bin-lin-rgb/blog-img@main/20231108205553.png" alt=""  />
</p>
<h2 id="tcp-重传">TCP 重传<a hidden class="anchor" aria-hidden="true" href="#tcp-重传">#</a></h2>
<p>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值。</p>
<p>快重传：发送1、2、3、4、5，但是 2 丢了，则回复 ack1，ack2，ack2，ack2，发现居然3个一样的ack，则说明丢包了。就是重传的时候，是重传一个，还是重传所有的问题。</p>
<p>SACK 方法：实现重传机制的方式叫：SACK（ Selective Acknowledgment）， 选择性确认。这种方式需要在 TCP 头部「选项」字段里加一个 SACK 的东西，它可以将已收到的数据的信息发送给「发送方」，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。</p>
<h2 id="滑动窗口">滑动窗口<a hidden class="anchor" aria-hidden="true" href="#滑动窗口">#</a></h2>
<p>窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。</p>
<p>通常窗口的大小是由接收方的窗口大小来决定的。</p>
<h2 id="流量控制">流量控制<a hidden class="anchor" aria-hidden="true" href="#流量控制">#</a></h2>
<p>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</p>
<p>如果发生了先减少缓存，再收缩窗口，就会出现丢包的现象。
为了防止这种情况发生，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。</p>
<h2 id="拥塞控制">拥塞控制<a hidden class="anchor" aria-hidden="true" href="#拥塞控制">#</a></h2>
<p>为什么要有拥塞控制呀，不是有流量控制了吗？</p>
<p>前面的流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。</p>
<p>1、慢启动</p>
<p>慢启动门限 <code>ssthresh</code> （slow start threshold）状态变量。</p>
<ul>
<li>当 <code>cwnd</code> &lt; <code>ssthresh</code> 时，使用慢启动算法。</li>
<li>当 <code>cwnd</code> &gt;= <code>ssthresh</code> 时，就会使用「拥塞避免算法」。</li>
</ul>
<p>2、进入拥塞避免算法后，它的规则是：每当收到一个 ACK 时，cwnd 增加 1</p>
<p>3、正如前面所说，进入快速恢复之前，cwnd 和 ssthresh 更新：</p>
<ul>
<li>cwnd = cwnd/2 ，也就是设置为原来的一半;</li>
<li>ssthresh = cwnd;</li>
</ul>
<p>然后，进入快速恢复算法如下：</p>
<ul>
<li>拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；</li>
<li>重传丢失的数据包；</li>
<li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li>
</ul>
<h1 id="ip">IP<a hidden class="anchor" aria-hidden="true" href="#ip">#</a></h1>
<h2 id="ping">PING<a hidden class="anchor" aria-hidden="true" href="#ping">#</a></h2>
<ul>
<li><code>127.0.0.1</code> 是<strong>回环地址</strong>。<code>localhost</code>是<strong>域名</strong>，但默认等于 <code>127.0.0.1</code>。</li>
<li><code>ping</code> 回环地址和 <code>ping</code> 本机地址，是一样的，走的是<strong>lo0 &ldquo;假网卡&rdquo;</strong>，都会经过网络层和数据链路层等逻辑，最后在快要出网卡前<strong>狠狠拐了个弯</strong>， 将数据插入到一个<strong>链表</strong>后就<strong>软中断</strong>通知 <strong>ksoftirqd</strong> 来进行<strong>收数据</strong>的逻辑，<strong>压根就不出网络</strong>。所以断网了也能 <code>ping</code> 通回环地址。</li>
<li>如果服务器 <code>listen</code> 的是 <code>0.0.0.0</code>，那么此时用<code>127.0.0.1</code>和本机地址<strong>都可以</strong>访问到服务。</li>
</ul>


        </div>
        <div class="post-reward">
            <div style="padding: 0 0 0 0; margin: 0 0 0 0; width: 100%; font-size:16px; text-align: center;">
                <div id="QR" style="opacity: 0;">
                    <div id="wechat" style="display: inline-block">
                        <a class="fancybox" rel="group">
                            <img id="wechat_qr" src="https://Bin-lin-rgb.github.io/img/wechat_pay.png" alt="wechat_pay"></a>
                        <p>微信</p>
                    </div>
                    <div id="alipay" style="display: inline-block">
                        <a class="fancybox" rel="group">
                            <img id="alipay_qr" src="https://Bin-lin-rgb.github.io/img/alipay.png" alt="alipay"></a>
                        <p>支付宝</p>
                    </div>
                </div>
                <button id="rewardButton"
                        onclick="
                    var qr = document.getElementById('QR');
                    if (qr.style.opacity === '0') {
                        qr.style.opacity='1';
                    } else {
                        qr.style.opacity='0'
                    }"
                >
                    <span>🧧 鼓励</span>
                </button>
            </div>
        </div>

        <footer class="post-footer">
            
<nav class="paginav">
  <a class="prev" href="https://Bin-lin-rgb.github.io/posts/go/%E9%9B%AA%E8%8A%B1id%E7%94%9F%E6%88%90%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BC%A0%E8%BE%93%E4%B8%8D%E4%B8%80%E8%87%B4/">
    <span class="title">« 上一页</span>
    <br>
    <span>雪花id生成，前后端传输不一致</span>
  </a>
  <a class="next" href="https://Bin-lin-rgb.github.io/posts/leetcode/top150/">
    <span class="title">下一页 »</span>
    <br>
    <span>Top150</span>
  </a>
</nav>

        </footer>
    </div>

<style>
    .comments_details summary::marker {
        font-size: 20px;
        content: '👉展开评论';
        color: var(--content);
    }
    .comments_details[open] summary::marker{
        font-size: 20px;
        content: '👇关闭评论';
        color: var(--content);
    }
</style>


<div>
    <details class="comments_details">
        <summary style="cursor: pointer; margin: 50px 0 20px 0;width: 130px;">
            <span style="font-size: 20px;color: var(--content);">...</span>
        </summary>
        <div id="tcomment"></div>
    </details>
    <script src="https://cdn.staticfile.org/twikoo/1.5.8/twikoo.all.min.js">
    </script>
    <script>
        twikoo.init({
            envId: 'https://twikoo-api-nine-silk.vercel.app/',
            el: "#tcomment",
            lang: 'zh-CN',
            region: 'ap-guangzhou',
            path: window.TWIKOO_MAGIC_PATH||window.location.pathname,
        })
    
    
    
    
    
    
    
    </script>
</div>
</article>
</main>

<footer class="footer">
    <span>
        Copyright
        &copy;
        2021-2023
        <a href="https://Bin-lin-rgb.github.io/" style="color:#939393;">Blaine&#39;s Blog</a>
        All Rights Reserved
    </span>
    <a href="https://beian.miit.gov.cn/" target="_blank" style="color:#939393;">备案号</a>&nbsp;
    <span>
        <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=null"
           style="display:inline-block;text-decoration:none;height:20px;color:#939393;">
            <img src="%e5%85%ac%e5%ae%89%e5%9b%be%e6%a0%87%e9%93%be%e6%8e%a5" style="float:left;margin: 0px 5px 0px 0px;"/>
            公网安备
        </a>
    </span>
    <span id="busuanzi_container">
        <span class="fa fa-user"></span> <span id="busuanzi_value_site_uv"></span>
        <span class="fa fa-eye"></span> <span id="busuanzi_value_site_pv"></span>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
    document.addEventListener('scroll', function (e) {
        const readProgress = document.getElementById("read_progress");
        const scrollHeight = document.documentElement.scrollHeight;
        const clientHeight = document.documentElement.clientHeight;
        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
    })
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
</script>
<script>
    let mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        (function() {
            document.cookie = "change-themes" + "="+ escape ("false");
        })()

        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    });
</script>

<script>
    document.body.addEventListener('copy', function (e) {
        if (window.getSelection().toString() && window.getSelection().toString().length > 50) {
            let clipboardData = e.clipboardData || window.clipboardData;
            if (clipboardData) {
                e.preventDefault();
                let htmlData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"Blaine's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                let textData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"Blaine's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                clipboardData.setData('text/html', htmlData);
                clipboardData.setData('text/plain', textData);
            }
        }
    });
</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;
        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = '复制';

        function copyingDone() {
            copybutton.innerText = '已复制！';
            setTimeout(() => {
                copybutton.innerText = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                let text = codeblock.textContent +
                    '\r\n————————————————\r\n' +
                    '版权声明：本文为「'+"Blaine's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                navigator.clipboard.writeText(text);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) {}
            selection.removeRange(range);
        });

        let language = codeblock.className.replaceAll("language-", "")
        let macTool = document.createElement("div")
        let macTool1 = document.createElement("div")
        let macTool2 = document.createElement("div")
        let macTool3 = document.createElement("div")
        let languageType = document.createElement("div")
        languageType.innerText = language
        macTool.setAttribute('class', 'mac-tool')
        macTool1.setAttribute('class', 'mac bb1')
        macTool2.setAttribute('class', 'mac bb2')
        macTool3.setAttribute('class', 'mac bb3')
        languageType.setAttribute('class', 'language-type')
        macTool.appendChild(macTool1)
        macTool.appendChild(macTool2)
        macTool.appendChild(macTool3)
        macTool.appendChild(languageType)

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
            container.appendChild(macTool)
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        }
    });
</script>
</body>

</html>
