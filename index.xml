<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Blaine&#39;s Blog</title>
    <link>https://Bin-lin-rgb.github.io/</link>
    <description>Recent content on Blaine&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Wed, 08 Nov 2023 21:18:50 +0800</lastBuildDate><atom:link href="https://Bin-lin-rgb.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Golang 基础语法</title>
      <link>https://Bin-lin-rgb.github.io/posts/go/base/</link>
      <pubDate>Tue, 30 Nov 2021 15:55:23 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/go/base/</guid>
      <description>Golang 基础语法</description>
    </item>
    
    <item>
      <title>Go 基础篇</title>
      <link>https://Bin-lin-rgb.github.io/posts/go/go%E5%9F%BA%E7%A1%80%E7%AF%87/</link>
      <pubDate>Wed, 01 Nov 2023 09:44:29 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/go/go%E5%9F%BA%E7%A1%80%E7%AF%87/</guid>
      <description>Go 方法与函数的区别？ 在 Go 语言中，有方法（method）和函数（function）两个概念，它们之间有一些重要的区别，主要体现在以下几个方面： 定义方式： 函数：函数是一段独立的代码块，它可以在任何地方定义和调用。函数的定义是全局的，可以在不同包中调用。 方法：方法是与类型（结构体或接口</description>
    </item>
    
    <item>
      <title>Go Slice篇</title>
      <link>https://Bin-lin-rgb.github.io/posts/go/go-slice%E7%AF%87/</link>
      <pubDate>Wed, 01 Nov 2023 09:45:04 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/go/go-slice%E7%AF%87/</guid>
      <description>Slice实现原理 Slice依托数组实现，底层数组对用户屏蔽，在底层数组容量不足时可以实现自动重分配并生成新的Slice。 接下来按照实际使用场景分别介绍其实现机制。 3.1 Slice数据结构 源码包中src/runtime/slice.go:slice定义了Slice的数据结构： type slice struct {</description>
    </item>
    
    <item>
      <title>Go Mutex篇</title>
      <link>https://Bin-lin-rgb.github.io/posts/go/go-mutex%E7%AF%87/</link>
      <pubDate>Wed, 01 Nov 2023 09:45:41 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/go/go-mutex%E7%AF%87/</guid>
      <description>Go 互斥锁的实现原理？ 互斥锁是并发程序中对共享资源进行访问控制的主要手段，对此Go语言提供了非常简单易用的Mutex，Mutex为一结构体类型，对外暴露两个方法Lock()和Unlock()分别用于加锁和解锁。 Mutex使用起来非常方便，但其内部实现却复杂得多，这包括Mutex的几</description>
    </item>
    
    <item>
      <title>Go Map篇</title>
      <link>https://Bin-lin-rgb.github.io/posts/go/go-map%E7%AF%87/</link>
      <pubDate>Wed, 01 Nov 2023 09:45:15 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/go/go-map%E7%AF%87/</guid>
      <description>1. map数据结构 Golang的map使用哈希表作为底层实现，一个哈希表里可以有多个哈希表节点，也即bucket，而每个bucket就保存了map中的一个或一组键值对。 map数据结构由runtime/map.go/hmap定义: // A header for a Go map. type hmap struct { count int // 代表哈希表中的元素个数，调</description>
    </item>
    
    <item>
      <title>Go Goroutine篇</title>
      <link>https://Bin-lin-rgb.github.io/posts/go/go-goroutine%E7%AF%87/</link>
      <pubDate>Wed, 01 Nov 2023 09:46:08 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/go/go-goroutine%E7%AF%87/</guid>
      <description>Go goroutine 的底层实现原理 概念 Goroutine 可以理解为一种 Go 语言的协程（轻量级线程），是 Go 支持高并发的基础，属于用户态的线程，由 Go runtime 管理而不是操作系统。 底层数据结构 type g struct { goid int64 // 唯一的goroutine的ID sched gobuf // goroutine切换时，用于保存g的上下文 stack stack // 栈 gopc // pc of go statement that created this goroutine startpc uintptr // pc of goroutine function</description>
    </item>
    
    <item>
      <title>Go Channel篇</title>
      <link>https://Bin-lin-rgb.github.io/posts/go/go-channel%E7%AF%87/</link>
      <pubDate>Wed, 01 Nov 2023 09:45:23 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/go/go-channel%E7%AF%87/</guid>
      <description>Go channel 的底层实现原理 概念： Go 中的 channel 是一个队列，遵循先进先出的原则，负责协程之间的通信（Go 语言提倡不要通过共享内存来通信，而要通过通信来实现内存共享，CSP(Communicating Sequential Process)并发模型，就是通过 goroutine 和 channel 来实现的） 使用场景： 停止信号监听 定时任务 生产方和消费方解</description>
    </item>
    
    <item>
      <title>Go 内存管理篇</title>
      <link>https://Bin-lin-rgb.github.io/posts/go/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87/</link>
      <pubDate>Wed, 01 Nov 2023 09:46:51 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/go/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87/</guid>
      <description>Go 内存分配机制 Go语言内置运行时（就是runtime），抛弃了传统的内存分配方式，改为自主管理。这样可以自主地实现更好的内存使用模式，比如内存池、预分配等等。这样，不会每次内存分配都需要进行系统调用。 设计思想 内存分配算法采用Google的TCMalloc算法，每个线程都会自行维护</description>
    </item>
    
    <item>
      <title>Go 调度模型篇</title>
      <link>https://Bin-lin-rgb.github.io/posts/go/go-%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B%E7%AF%87/</link>
      <pubDate>Wed, 01 Nov 2023 09:46:37 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/go/go-%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B%E7%AF%87/</guid>
      <description>Go 线程实现模型 Go实现的是两级线程模型（M：N)，准确的说是GMP模型，是对两级线程模型的改进实现，使它能够更加灵活地进行线程之间的调度。 背景 含义 缺点 单进程时代 每个程序就是一个进程，直到一个程序运行完，才能进行下一个进程 1. 无法并发，只能串行 2. 进程阻塞所带来的 CPU 时间浪费 多进程/线程</description>
    </item>
    
    <item>
      <title>Go 并发编程篇</title>
      <link>https://Bin-lin-rgb.github.io/posts/go/go-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AF%87/</link>
      <pubDate>Wed, 01 Nov 2023 09:46:59 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/go/go-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AF%87/</guid>
      <description>1.Go 常用的并发模型 并发模型说的是系统中的线程如何协作完成并发任务，不同的并发模型，线程以不同的方式进行通信和协作。 线程间通信方式 线程间通信方式有两种：共享内存和消息传递，无论是哪种通信模型，线程或者协程最终都会从内存中获取数据，所以更为准确的说法是直接共享内存、发送消息的方式来同步</description>
    </item>
    
    <item>
      <title>Redis</title>
      <link>https://Bin-lin-rgb.github.io/posts/basics/redis/</link>
      <pubDate>Wed, 08 Nov 2023 21:18:50 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/basics/redis/</guid>
      <description>持续更新中&amp;hellip; 感觉这篇写的不错 Others 缓存击穿、穿透</description>
    </item>
    
    <item>
      <title>MySQL</title>
      <link>https://Bin-lin-rgb.github.io/posts/basics/mysql/</link>
      <pubDate>Wed, 08 Nov 2023 21:18:41 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/basics/mysql/</guid>
      <description>Basic 执行一条 SQL 查询语句，期间发生了什么？ 连接器：建立连接，管理连接、校验用户身份； 查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块； 解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型</description>
    </item>
    
    <item>
      <title>操作系统</title>
      <link>https://Bin-lin-rgb.github.io/posts/basics/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Wed, 08 Nov 2023 21:18:35 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/basics/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
      <description></description>
    </item>
    
    <item>
      <title>回溯</title>
      <link>https://Bin-lin-rgb.github.io/posts/leetcode/%E5%9B%9E%E6%BA%AF/</link>
      <pubDate>Tue, 07 Nov 2023 21:39:19 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/leetcode/%E5%9B%9E%E6%BA%AF/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Linux常用命令</title>
      <link>https://Bin-lin-rgb.github.io/posts/deploy/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Tue, 07 Nov 2023 19:46:01 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/deploy/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>一般参数的意思 -a all（全部） -r recursion（递归） -f force（强制） -h 以K，M，G为单位，提高信息的可读性。 一、文件目录操作 1. ls 命令 ls 命令不仅可以查看 linux 文件夹包含的文件而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。 命令格式 ls [选项][目录名] 常用参</description>
    </item>
    
    <item>
      <title>动态规划</title>
      <link>https://Bin-lin-rgb.github.io/posts/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
      <pubDate>Tue, 07 Nov 2023 09:57:55 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
      <description>动态规划的解题步骤 &amp;ndash; from 代码随想录 做动规题目的时候，很多同学会陷入一个误区，就是以为把状态转移公式背下来，照葫芦画瓢改改，就开始写代码，甚至把题目 AC 之后，都不太清楚 dp[i]表示的是什么。 这就是一种朦胧的状态，然后就把题给过了，遇到稍稍难一点的，可能直接就不会了，然后看题解，然后继</description>
    </item>
    
    <item>
      <title>二叉树</title>
      <link>https://Bin-lin-rgb.github.io/posts/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 06 Nov 2023 21:09:14 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>参考labuladong的算法笔记进行刷题</description>
    </item>
    
    <item>
      <title>排序</title>
      <link>https://Bin-lin-rgb.github.io/posts/leetcode/%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Mon, 06 Nov 2023 21:04:31 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/leetcode/%E6%8E%92%E5%BA%8F/</guid>
      <description>快速排序 package main import &amp;#34;math/rand&amp;#34; func SortArray(nums []int) []int { quick(nums, 0, len(nums)-1) return nums } func quick(arr []int, i, j int) { if i &amp;gt;= j { return } mid := partition(arr, i, j) quick(arr, i, mid-1) quick(arr, mid+1, j) } func partition(nums []int, i int, j int) int { // 随机选择“支点”位置 p := rand.Intn(j-i+1) + i // 交换支点和第一个元素 nums[i], nums[p] = nums[p], nums[i] for i &amp;lt; j { // 从右向左找到第一个小于支点的元素 for nums[i] &amp;lt; nums[j] &amp;amp;&amp;amp; i &amp;lt; j { j-- } // 交换元素，将较小的元素移至左侧 if i &amp;lt; j {</description>
    </item>
    
    <item>
      <title>双指针（数组）</title>
      <link>https://Bin-lin-rgb.github.io/posts/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 06 Nov 2023 20:29:28 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84/</guid>
      <description>参考labuladong的算法笔记进行刷题</description>
    </item>
    
    <item>
      <title>Some_examples</title>
      <link>https://Bin-lin-rgb.github.io/posts/go/some_examples/</link>
      <pubDate>Mon, 06 Nov 2023 20:09:45 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/go/some_examples/</guid>
      <description>协程交替打印 a1b2c3&amp;hellip; package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sync&amp;#34; ) func main() { var wg sync.WaitGroup wg.Add(1) chNumber := make(chan struct{}) chLetter := make(chan struct{}) i := 1 index := 0 a := &amp;#34;&amp;#34; for c := &amp;#39;a&amp;#39;; c &amp;lt;= &amp;#39;z&amp;#39;; c++ { a = a + string(c) } go func() { for { select { case &amp;lt;-chNumber: fmt.Print(i) i++ chLetter &amp;lt;- struct{}{} break default: break } } }() go func(wg *sync.WaitGroup) { for { select { case &amp;lt;-chLetter: if index &amp;gt; len(a)-1 { wg.Done() return } fmt.Print(string(a[index])) index++ chNumber &amp;lt;- struct{}{} break default: break } } }(&amp;amp;wg) chLetter &amp;lt;- struct{}{} wg.Wait() } 并发3个函数 f1()(int[],error),f2()(int[</description>
    </item>
    
    <item>
      <title>双指针（链表）</title>
      <link>https://Bin-lin-rgb.github.io/posts/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 06 Nov 2023 19:13:15 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88%E9%93%BE%E8%A1%A8/</guid>
      <description>参考labuladong的算法笔记进行刷题</description>
    </item>
    
    <item>
      <title>雪花id生成，前后端传输不一致</title>
      <link>https://Bin-lin-rgb.github.io/posts/go/%E9%9B%AA%E8%8A%B1id%E7%94%9F%E6%88%90%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BC%A0%E8%BE%93%E4%B8%8D%E4%B8%80%E8%87%B4/</link>
      <pubDate>Mon, 30 Oct 2023 10:53:54 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/go/%E9%9B%AA%E8%8A%B1id%E7%94%9F%E6%88%90%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BC%A0%E8%BE%93%E4%B8%8D%E4%B8%80%E8%87%B4/</guid>
      <description>前言 今天发现后端使用雪花算法生成的 PostId 传给前端之后，居然不一致！ 导致文章详情页带参数查询为空！ 为啥会这样呢？ 什么是雪花算法？ 雪花算法，Twitter 的分布式自增 ID 算法 snowflake 优缺点： 优点： （1）经测试 snowflake 每秒能生成 26 万个自增可排序的 ID。 （2）snowflake 生成的 ID 结果是一个 64bit 大小的整</description>
    </item>
    
    <item>
      <title>计算机网络</title>
      <link>https://Bin-lin-rgb.github.io/posts/basics/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Sun, 29 Oct 2023 16:34:43 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/basics/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</guid>
      <description>基础篇 OSI 七层参考模型 它是⼀个七层的、抽象的模型体，不仅包括⼀系列抽象的术语或概念，也包括具体的协议。 物理层：它的主要作⽤是传输⽐特流 数据链路层：建⽴逻辑连接、进⾏硬件地址寻址、差错校验等功能。定义了如何让格式化数据以帧为单位进⾏传 输，以及如何控制对物理介质的访问。将⽐特组合成字节</description>
    </item>
    
    <item>
      <title>Top150</title>
      <link>https://Bin-lin-rgb.github.io/posts/leetcode/top150/</link>
      <pubDate>Sat, 28 Oct 2023 21:53:51 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/leetcode/top150/</guid>
      <description>数组/字符串 [27. 移除元素] (https://leetcode.cn/problems/remove-element/) 简单 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1： 输入：nums = [3,2,2,3], val = 3</description>
    </item>
    
    <item>
      <title>Docker 基础</title>
      <link>https://Bin-lin-rgb.github.io/posts/deploy/docker/</link>
      <pubDate>Sat, 28 Oct 2023 18:35:29 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/deploy/docker/</guid>
      <description>Docker 为什么使用Docker 企业环境中存在的某个痛点 企业使用一项技术是为了解决当前企业环境中存在的某个痛点。 目前整个软件行业存在着以下几个痛点。 1.软件更新发布及部署低效，过程烦琐且需要人工介入。 2.环境一致性难以保证。 3.不同环境之间迁移成本太高。 Docker能解决的问题 首先，Do</description>
    </item>
    
    <item>
      <title>Redis scan命令学习</title>
      <link>https://Bin-lin-rgb.github.io/posts/tech/tech/</link>
      <pubDate>Wed, 30 Nov 2022 15:55:23 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/tech/tech/</guid>
      <description>scan命令详解</description>
    </item>
    
    <item>
      <title>Zap日志库</title>
      <link>https://Bin-lin-rgb.github.io/posts/go/zap%E6%97%A5%E5%BF%97%E5%BA%93/</link>
      <pubDate>Sun, 30 Oct 2022 10:39:16 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/go/zap%E6%97%A5%E5%BF%97%E5%BA%93/</guid>
      <description>前言 zap 的使用。 安装 运行下面的命令安装zap go get -u go.uber.org/zap 实现 logger.go 文件 先在 logger 下新建一个文件 具体内容如下： package Logger import ( &amp;#34;github.com/gin-gonic/gin&amp;#34; &amp;#34;go.uber.org/zap&amp;#34; &amp;#34;go.uber.org/zap/zapcore&amp;#34; &amp;#34;gopkg.in/natefinch/lumberjack.v2&amp;#34; &amp;#34;net&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;net/http/httputil&amp;#34; &amp;#34;os&amp;#34; &amp;#34;runtime/debug&amp;#34; &amp;#34;server/Config&amp;#34; &amp;#34;strings&amp;#34; &amp;#34;time&amp;#34; ) var lg *zap.Logger // InitLogger 初始化Logger func InitLogger(cfg *Config.LogConfig) (err error) { writeSyncer := getLogWriter(cfg.Filename, cfg.MaxSize, cfg.MaxBackups, cfg.MaxAge) encoder := getEncoder() var l = new(zapcore.Level) err = l.UnmarshalText([]byte(cfg.Level)) if err != nil { return } core := zapcore.NewCore(encoder, writeSyncer, l) lg = zap.New(core, zap.AddCaller()) zap.ReplaceGlobals(lg) // 替换zap包中全局的logger实例，后续在</description>
    </item>
    
    <item>
      <title>Golang集成gorm</title>
      <link>https://Bin-lin-rgb.github.io/posts/go/golang%E9%9B%86%E6%88%90gorm/</link>
      <pubDate>Sun, 30 Oct 2022 10:35:11 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/go/golang%E9%9B%86%E6%88%90gorm/</guid>
      <description>gorm基础使用及解决部分疑惑 这是我参与「第三届青训营 -后端场」笔记创作活动的第4篇笔记。 01 简介 本文主要介绍在项目中集成 gorm 的大致方法、一些错误的解决方法、规范包及目录。 02 规范包及目录 这只是其中的一种分包方式，具体使用哪种可以根据自己需求。 controller //处理函数 ​ dao //数据库相关，gorm</description>
    </item>
    
    <item>
      <title>使用 FFmpeg 截取视频第一帧并保存案例</title>
      <link>https://Bin-lin-rgb.github.io/posts/go/%E4%BD%BF%E7%94%A8ffmpeg/</link>
      <pubDate>Sun, 30 Oct 2022 10:26:55 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/go/%E4%BD%BF%E7%94%A8ffmpeg/</guid>
      <description>运行准备 由于需要使用 FFmpeg 第三方工具来完成视频截取第一帧作为封面并存储到本机， 所以运行之前需要预先安装 FFmpeg 到本机并配置好环境变量。 我这里使用的是 ffmpeg version 5.0.1-full_build 版本。 参考链接：FFmpeg 项目结构 假设有这样一个案例：assets 文件夹中是专门存放视频的，现在的要求就是将该视频的第一帧截取为图片并</description>
    </item>
    
    <item>
      <title>omitempty 关键字</title>
      <link>https://Bin-lin-rgb.github.io/posts/go/omitempty/</link>
      <pubDate>Sat, 29 Oct 2022 16:00:07 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/go/omitempty/</guid>
      <description>Golang 的 “omitempty” 关键字略解</description>
    </item>
    
    <item>
      <title>Life</title>
      <link>https://Bin-lin-rgb.github.io/posts/life/life/</link>
      <pubDate>Thu, 05 May 2022 00:18:15 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/life/life/</guid>
      <description></description>
    </item>
    
    <item>
      <title>🤝友链</title>
      <link>https://Bin-lin-rgb.github.io/links/</link>
      <pubDate>Sat, 06 Nov 2021 15:15:53 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/links/</guid>
      <description>Blaine&amp;#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Blaine&amp;rsquo;s Blog 网址： https://bin-lin-rgb.github.io/ 图标： https://bin-lin-rgb.github.io/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内</description>
    </item>
    
    <item>
      <title>🙋🏻‍♂️关于</title>
      <link>https://Bin-lin-rgb.github.io/about/</link>
      <pubDate>Sat, 06 Nov 2021 14:57:28 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/about/</guid>
      <description>关于我 英文名: Blaine 职业: 程序员 运动: 跑步、乒乓球</description>
    </item>
    
    <item>
      <title>Blog</title>
      <link>https://Bin-lin-rgb.github.io/posts/tech/blog/</link>
      <pubDate>Tue, 05 May 2020 00:18:23 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/tech/blog/</guid>
      <description>使用 hugo + GitHub Pages + twikoo 完成</description>
    </item>
    
    
    
  </channel>
</rss>
