<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Blaine&#39;s Blog</title>
    <link>https://Bin-lin-rgb.github.io/</link>
    <description>Recent content on Blaine&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Wed, 01 Nov 2023 09:46:59 +0800</lastBuildDate><atom:link href="https://Bin-lin-rgb.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Golang 基础语法</title>
      <link>https://Bin-lin-rgb.github.io/posts/go/base/</link>
      <pubDate>Tue, 30 Nov 2021 15:55:23 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/go/base/</guid>
      <description>Golang 基础语法</description>
    </item>
    
    <item>
      <title>Go 并发编程篇</title>
      <link>https://Bin-lin-rgb.github.io/posts/go/go-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AF%87/</link>
      <pubDate>Wed, 01 Nov 2023 09:46:59 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/go/go-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AF%87/</guid>
      <description>1.Go 常用的并发模型 并发模型说的是系统中的线程如何协作完成并发任务，不同的并发模型，线程以不同的方式进行通信和协作。 线程间通信方式 线程间通信方式有两种：共享内存和消息传递，无论是哪种通信模型，线程或者协程最终都会从内存中获取数据，所以更为准确的说法是直接共享内存、发送消息的方式来同步</description>
    </item>
    
    <item>
      <title>Go 内存管理篇</title>
      <link>https://Bin-lin-rgb.github.io/posts/go/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87/</link>
      <pubDate>Wed, 01 Nov 2023 09:46:51 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/go/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87/</guid>
      <description>Go 内存分配机制 Go语言内置运行时（就是runtime），抛弃了传统的内存分配方式，改为自主管理。这样可以自主地实现更好的内存使用模式，比如内存池、预分配等等。这样，不会每次内存分配都需要进行系统调用。 设计思想 内存分配算法采用Google的TCMalloc算法，每个线程都会自行维护</description>
    </item>
    
    <item>
      <title>Go 调度模型篇</title>
      <link>https://Bin-lin-rgb.github.io/posts/go/go-%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B%E7%AF%87/</link>
      <pubDate>Wed, 01 Nov 2023 09:46:37 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/go/go-%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B%E7%AF%87/</guid>
      <description>Go 线程实现模型 Go实现的是两级线程模型（M：N)，准确的说是GMP模型，是对两级线程模型的改进实现，使它能够更加灵活地进行线程之间的调度。 背景 含义 缺点 单进程时代 每个程序就是一个进程，直到一个程序运行完，才能进行下一个进程 1. 无法并发，只能串行 2. 进程阻塞所带来的 CPU 时间浪费 多进程/线程</description>
    </item>
    
    <item>
      <title>Go Goroutine篇</title>
      <link>https://Bin-lin-rgb.github.io/posts/go/go-goroutine%E7%AF%87/</link>
      <pubDate>Wed, 01 Nov 2023 09:46:08 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/go/go-goroutine%E7%AF%87/</guid>
      <description>Go goroutine 的底层实现原理 概念 Goroutine 可以理解为一种 Go 语言的协程（轻量级线程），是 Go 支持高并发的基础，属于用户态的线程，由 Go runtime 管理而不是操作系统。 底层数据结构 type g struct { goid int64 // 唯一的goroutine的ID sched gobuf // goroutine切换时，用于保存g的上下文 stack stack // 栈 gopc // pc of go statement that created this goroutine startpc uintptr // pc of goroutine function</description>
    </item>
    
    <item>
      <title>Go Mutex篇</title>
      <link>https://Bin-lin-rgb.github.io/posts/go/go-mutex%E7%AF%87/</link>
      <pubDate>Wed, 01 Nov 2023 09:45:41 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/go/go-mutex%E7%AF%87/</guid>
      <description>Go 互斥锁的实现原理？ 互斥锁是并发程序中对共享资源进行访问控制的主要手段，对此Go语言提供了非常简单易用的Mutex，Mutex为一结构体类型，对外暴露两个方法Lock()和Unlock()分别用于加锁和解锁。 Mutex使用起来非常方便，但其内部实现却复杂得多，这包括Mutex的几</description>
    </item>
    
    <item>
      <title>Go Channel篇</title>
      <link>https://Bin-lin-rgb.github.io/posts/go/go-channel%E7%AF%87/</link>
      <pubDate>Wed, 01 Nov 2023 09:45:23 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/go/go-channel%E7%AF%87/</guid>
      <description>Go channel 的底层实现原理 概念： Go 中的 channel 是一个队列，遵循先进先出的原则，负责协程之间的通信（Go 语言提倡不要通过共享内存来通信，而要通过通信来实现内存共享，CSP(Communicating Sequential Process)并发模型，就是通过 goroutine 和 channel 来实现的） 使用场景： 停止信号监听 定时任务 生产方和消费方解</description>
    </item>
    
    <item>
      <title>Go Map篇</title>
      <link>https://Bin-lin-rgb.github.io/posts/go/go-map%E7%AF%87/</link>
      <pubDate>Wed, 01 Nov 2023 09:45:15 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/go/go-map%E7%AF%87/</guid>
      <description>1. map数据结构 Golang的map使用哈希表作为底层实现，一个哈希表里可以有多个哈希表节点，也即bucket，而每个bucket就保存了map中的一个或一组键值对。 map数据结构由runtime/map.go/hmap定义: // A header for a Go map. type hmap struct { count int // 代表哈希表中的元素个数，调</description>
    </item>
    
    <item>
      <title>Go Slice篇</title>
      <link>https://Bin-lin-rgb.github.io/posts/go/go-slice%E7%AF%87/</link>
      <pubDate>Wed, 01 Nov 2023 09:45:04 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/go/go-slice%E7%AF%87/</guid>
      <description>Slice实现原理 Slice依托数组实现，底层数组对用户屏蔽，在底层数组容量不足时可以实现自动重分配并生成新的Slice。 接下来按照实际使用场景分别介绍其实现机制。 3.1 Slice数据结构 源码包中src/runtime/slice.go:slice定义了Slice的数据结构： type slice struct {</description>
    </item>
    
    <item>
      <title>Go 基础篇</title>
      <link>https://Bin-lin-rgb.github.io/posts/go/go%E5%9F%BA%E7%A1%80%E7%AF%87/</link>
      <pubDate>Wed, 01 Nov 2023 09:44:29 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/go/go%E5%9F%BA%E7%A1%80%E7%AF%87/</guid>
      <description>Go 方法与函数的区别？ 在 Go 语言中，有方法（method）和函数（function）两个概念，它们之间有一些重要的区别，主要体现在以下几个方面： 定义方式： 函数：函数是一段独立的代码块，它可以在任何地方定义和调用。函数的定义是全局的，可以在不同包中调用。 方法：方法是与类型（结构体或接口</description>
    </item>
    
    <item>
      <title>雪花id生成，前后端传输不一致</title>
      <link>https://Bin-lin-rgb.github.io/posts/go/%E9%9B%AA%E8%8A%B1id%E7%94%9F%E6%88%90%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BC%A0%E8%BE%93%E4%B8%8D%E4%B8%80%E8%87%B4/</link>
      <pubDate>Mon, 30 Oct 2023 10:53:54 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/go/%E9%9B%AA%E8%8A%B1id%E7%94%9F%E6%88%90%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BC%A0%E8%BE%93%E4%B8%8D%E4%B8%80%E8%87%B4/</guid>
      <description>前言 今天发现后端使用雪花算法生成的 PostId 传给前端之后，居然不一致！ 导致文章详情页带参数查询为空！ 为啥会这样呢？ 什么是雪花算法？ 雪花算法，Twitter 的分布式自增 ID 算法 snowflake 优缺点： 优点： （1）经测试 snowflake 每秒能生成 26 万个自增可排序的 ID。 （2）snowflake 生成的 ID 结果是一个 64bit 大小的整</description>
    </item>
    
    <item>
      <title>计算机网络之基础篇</title>
      <link>https://Bin-lin-rgb.github.io/posts/basics/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%AF%87/</link>
      <pubDate>Sun, 29 Oct 2023 16:34:43 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/basics/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%AF%87/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Top150</title>
      <link>https://Bin-lin-rgb.github.io/posts/leetcode/top150/</link>
      <pubDate>Sat, 28 Oct 2023 21:53:51 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/leetcode/top150/</guid>
      <description>数组/字符串 [27. 移除元素] (https://leetcode.cn/problems/remove-element/) 简单 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1： 输入：nums = [3,2,2,3], val = 3</description>
    </item>
    
    <item>
      <title>Docker 基础</title>
      <link>https://Bin-lin-rgb.github.io/posts/deploy/docker/</link>
      <pubDate>Sat, 28 Oct 2023 18:35:29 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/deploy/docker/</guid>
      <description>Docker 为什么使用Docker 企业环境中存在的某个痛点 企业使用一项技术是为了解决当前企业环境中存在的某个痛点。 目前整个软件行业存在着以下几个痛点。 1.软件更新发布及部署低效，过程烦琐且需要人工介入。 2.环境一致性难以保证。 3.不同环境之间迁移成本太高。 Docker能解决的问题 首先，Do</description>
    </item>
    
    <item>
      <title>Redis scan命令学习</title>
      <link>https://Bin-lin-rgb.github.io/posts/tech/tech/</link>
      <pubDate>Wed, 30 Nov 2022 15:55:23 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/tech/tech/</guid>
      <description>scan命令详解</description>
    </item>
    
    <item>
      <title>Zap日志库</title>
      <link>https://Bin-lin-rgb.github.io/posts/go/zap%E6%97%A5%E5%BF%97%E5%BA%93/</link>
      <pubDate>Sun, 30 Oct 2022 10:39:16 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/go/zap%E6%97%A5%E5%BF%97%E5%BA%93/</guid>
      <description>前言 zap 的使用。 安装 运行下面的命令安装zap go get -u go.uber.org/zap 实现 logger.go 文件 先在 logger 下新建一个文件 具体内容如下： package Logger import ( &amp;#34;github.com/gin-gonic/gin&amp;#34; &amp;#34;go.uber.org/zap&amp;#34; &amp;#34;go.uber.org/zap/zapcore&amp;#34; &amp;#34;gopkg.in/natefinch/lumberjack.v2&amp;#34; &amp;#34;net&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;net/http/httputil&amp;#34; &amp;#34;os&amp;#34; &amp;#34;runtime/debug&amp;#34; &amp;#34;server/Config&amp;#34; &amp;#34;strings&amp;#34; &amp;#34;time&amp;#34; ) var lg *zap.Logger // InitLogger 初始化Logger func InitLogger(cfg *Config.LogConfig) (err error) { writeSyncer := getLogWriter(cfg.Filename, cfg.MaxSize, cfg.MaxBackups, cfg.MaxAge) encoder := getEncoder() var l = new(zapcore.Level) err = l.UnmarshalText([]byte(cfg.Level)) if err != nil { return } core := zapcore.NewCore(encoder, writeSyncer, l) lg = zap.New(core, zap.AddCaller()) zap.ReplaceGlobals(lg) // 替换zap包中全局的logger实例，后续在</description>
    </item>
    
    <item>
      <title>Golang集成gorm</title>
      <link>https://Bin-lin-rgb.github.io/posts/go/golang%E9%9B%86%E6%88%90gorm/</link>
      <pubDate>Sun, 30 Oct 2022 10:35:11 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/go/golang%E9%9B%86%E6%88%90gorm/</guid>
      <description>gorm基础使用及解决部分疑惑 这是我参与「第三届青训营 -后端场」笔记创作活动的第4篇笔记。 01 简介 本文主要介绍在项目中集成 gorm 的大致方法、一些错误的解决方法、规范包及目录。 02 规范包及目录 这只是其中的一种分包方式，具体使用哪种可以根据自己需求。 controller //处理函数 ​ dao //数据库相关，gorm</description>
    </item>
    
    <item>
      <title>使用 FFmpeg 截取视频第一帧并保存案例</title>
      <link>https://Bin-lin-rgb.github.io/posts/go/%E4%BD%BF%E7%94%A8ffmpeg/</link>
      <pubDate>Sun, 30 Oct 2022 10:26:55 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/go/%E4%BD%BF%E7%94%A8ffmpeg/</guid>
      <description>运行准备 由于需要使用 FFmpeg 第三方工具来完成视频截取第一帧作为封面并存储到本机， 所以运行之前需要预先安装 FFmpeg 到本机并配置好环境变量。 我这里使用的是 ffmpeg version 5.0.1-full_build 版本。 参考链接：FFmpeg 项目结构 假设有这样一个案例：assets 文件夹中是专门存放视频的，现在的要求就是将该视频的第一帧截取为图片并</description>
    </item>
    
    <item>
      <title>omitempty 关键字</title>
      <link>https://Bin-lin-rgb.github.io/posts/go/omitempty/</link>
      <pubDate>Sat, 29 Oct 2022 16:00:07 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/go/omitempty/</guid>
      <description>Golang 的 “omitempty” 关键字略解</description>
    </item>
    
    <item>
      <title>Life</title>
      <link>https://Bin-lin-rgb.github.io/posts/life/life/</link>
      <pubDate>Thu, 05 May 2022 00:18:15 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/life/life/</guid>
      <description></description>
    </item>
    
    <item>
      <title>🤝友链</title>
      <link>https://Bin-lin-rgb.github.io/links/</link>
      <pubDate>Sat, 06 Nov 2021 15:15:53 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/links/</guid>
      <description>Blaine&amp;#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Blaine&amp;rsquo;s Blog 网址： https://bin-lin-rgb.github.io/ 图标： https://bin-lin-rgb.github.io/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内</description>
    </item>
    
    <item>
      <title>🙋🏻‍♂️关于</title>
      <link>https://Bin-lin-rgb.github.io/about/</link>
      <pubDate>Sat, 06 Nov 2021 14:57:28 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/about/</guid>
      <description>关于我 英文名: Blaine 职业: 程序员 运动: 跑步、乒乓球</description>
    </item>
    
    <item>
      <title>Blog</title>
      <link>https://Bin-lin-rgb.github.io/posts/tech/blog/</link>
      <pubDate>Tue, 05 May 2020 00:18:23 +0800</pubDate>
      
      <guid>https://Bin-lin-rgb.github.io/posts/tech/blog/</guid>
      <description>使用 hugo + GitHub Pages + twikoo 完成</description>
    </item>
    
    
    
  </channel>
</rss>
